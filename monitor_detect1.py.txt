#!/usr/bin/env python3
import os
import sqlite3
import datetime
import math
import subprocess
import signal
import smtplib
import shutil
import threading
import time
import logging
from email.message import EmailMessage
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# === Configuration ===
WATCH_PATH = "/home/kali/personal_1000"
ADMIN_EMAIL = "admin@localhost"
USE_LOCAL_SMTP = True
SMTP_SERVER = "smtp.example.com"
SMTP_PORT = 587
SMTP_USER = ""
SMTP_PASS = ""
WHITELIST_CMDS = []  # add substrings of commands to ignore, e.g., ["sshd", "systemd"]
SUSPEND_ACTION = "stop"  # "stop" for SIGSTOP, "kill" for SIGKILL
ENTROPY_READ_LIMIT = 1024 * 1024  # read up to 1MB for entropy check

# === Logging ===
logging.basicConfig(
    filename="monitor_detect.log",
    level=logging.INFO,
    format="%(asctime)s %(levelname)s %(message)s"
)

# === Setup SQLite Logging ===
conn = sqlite3.connect('access_log.db', check_same_thread=False)
cursor = conn.cursor()
cursor.execute('''
CREATE TABLE IF NOT EXISTS access_events (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    timestamp TEXT,
    event_type TEXT,
    file_path TEXT,
    alert TEXT
)
''')
conn.commit()

# === Entropy Check ===
def calculate_entropy(data: bytes) -> float:
    if not data:
        return 0.0
    length = len(data)
    counts = {}
    for b in data:
        counts[b] = counts.get(b, 0) + 1
    entropy = 0.0
    for count in counts.values():
        p_x = count / length
        entropy -= p_x * math.log2(p_x)
    return entropy

def is_encrypted(file_path: str) -> bool:
    try:
        with open(file_path, 'rb') as f:
            data = f.read(ENTROPY_READ_LIMIT)
            entropy = calculate_entropy(data)
            logging.debug(f"Entropy for {file_path}: {entropy:.3f}")
            return entropy > 7.5
    except Exception as e:
        logging.debug(f"Could not read {file_path} for entropy: {e}")
        return False

# === Logging Function ===
def log_event(event_type: str, file_path: str, alert: str = None):
    timestamp = datetime.datetime.now().isoformat()
    cursor.execute('''
        INSERT INTO access_events (timestamp, event_type, file_path, alert)
        VALUES (?, ?, ?, ?)
    ''', (timestamp, event_type, file_path, alert))
    conn.commit()
    logging.info(f"{event_type} {file_path} {alert or ''}")

# === Process Helpers ===
def get_cmdline(pid: int) -> str:
    try:
        with open(f"/proc/{pid}/cmdline", "rb") as f:
            raw = f.read().replace(b'\x00', b' ').strip()
            return raw.decode(errors="ignore")
    except Exception:
        return ""

def kill_process_using_file(file_path: str, action: str = "stop") -> list:
    suspended = []
    try:
        # Prefer lsof -t to get PIDs only
        output = subprocess.check_output(['lsof', '-t', file_path], stderr=subprocess.DEVNULL).decode().strip()
        if not output:
            return suspended
        for line in output.splitlines():
            try:
                pid = int(line.strip())
            except ValueError:
                continue
            if pid == os.getpid():
                continue
            cmd = get_cmdline(pid)
            if any(w in cmd for w in WHITELIST_CMDS):
                logging.info(f"Skipping whitelisted process {pid} ({cmd})")
                continue
            sig = signal.SIGSTOP if action == "stop" else signal.SIGKILL
            try:
                os.kill(pid, sig)
                suspended.append(pid)
                logging.info(f"Signaled {pid} ({cmd}) with {sig}")
            except PermissionError:
                logging.error(f"Permission denied signaling pid {pid}")
            except ProcessLookupError:
                logging.warning(f"Process {pid} disappeared before signaling")
    except subprocess.CalledProcessError:
        logging.debug("lsof returned no processes for file")
    except FileNotFoundError:
        logging.error("lsof not installed; install lsof to enable process lookup")
    except Exception as e:
        logging.exception(f"Unexpected error in kill_process_using_file: {e}")
    return suspended

# === Notification ===
def send_notification(file_path: str, pids: list):
    title = "Security Alert"
    body = f"Suspicious encryption detected on {file_path}\nSuspended PIDs: {pids or 'none'}"
    # Desktop notification if available
    if shutil.which("notify-send"):
        try:
            subprocess.run(["notify-send", title, body], check=False)
            logging.info("Desktop notification sent")
            return
        except Exception as e:
            logging.error(f"notify-send failed: {e}")
    # Fallback to email
    try:
        msg = EmailMessage()
        msg.set_content(body)
        msg['Subject'] = 'Security Alert: Possible Keylogger Activity'
        msg['From'] = f"monitor@{os.uname().nodename}"
        msg['To'] = ADMIN_EMAIL
        if USE_LOCAL_SMTP:
            with smtplib.SMTP('localhost') as server:
                server.send_message(msg)
        else:
            with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
                server.starttls()
                if SMTP_USER and SMTP_PASS:
                    server.login(SMTP_USER, SMTP_PASS)
                server.send_message(msg)
        logging.info("Email notification sent")
    except Exception as e:
        logging.exception(f"Failed to send email notification: {e}")

# === Watchdog Handler ===
class MonitorHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if event.is_directory:
            return
        file_path = event.src_path
        if is_encrypted(file_path):
            alert_text = "ALERT: Possible encryption attempt"
            log_event('MODIFIED', file_path, alert_text)
            print(f"[ALERT] Suspicious encryption detected: {file_path}")
            logging.warning(f"Suspicious encryption detected: {file_path}")
            def handle_alert(fp):
                if os.geteuid() != 0:
                    logging.warning("Not running as root; cannot suspend processes. Notification will still be sent.")
                pids = kill_process_using_file(fp, action=SUSPEND_ACTION)
                send_notification(fp, pids)
            threading.Thread(target=handle_alert, args=(file_path,), daemon=True).start()
        else:
            log_event('MODIFIED', file_path)

# === Start Monitoring ===
def start_monitoring(path_to_watch: str):
    if not os.path.exists(path_to_watch):
        os.makedirs(path_to_watch, exist_ok=True)
        logging.info(f"Created missing watch directory: {path_to_watch}")
    event_handler = MonitorHandler()
    observer = Observer()
    observer.schedule(event_handler, path=path_to_watch, recursive=True)
    observer.start()
    print(f"Monitoring started on: {path_to_watch}")
    logging.info(f"Monitoring started on: {path_to_watch}")
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

# === Run ===
if __name__ == "__main__":
    start_monitoring(WATCH_PATH)
